<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Stream (luv.Luv.Stream)</title><link rel="stylesheet" href="../../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 1.5.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> – <a href="../../index.html">luv</a> &#x00BB; <a href="../index.html">Luv</a> &#x00BB; Stream</nav><h1>Module <code>Luv.Stream</code></h1><p>Streams.</p><p>See <a href="https://aantron.github.io/luv/networking.html#tcp"><i>TCP</i></a> in the user guide and <a href="http://docs.libuv.org/en/v1.x/stream.html"><code>uv_stream_t</code> <i>— Stream handle</i></a> in libuv.</p><p>Several types of <a href="../Handle/index.html#type-t"><span>handle</span></a> have a portion of their interface in common, which portion is abstracted out into this module <a href="index.html"><code>Luv.Stream</code></a>.</p><p>Concrete streams are:</p><ul><li><a href="../Pipe/index.html#type-t"><code>Luv.Pipe.t</code></a></li><li><a href="../TCP/index.html#type-t"><code>Luv.TCP.t</code></a></li><li><a href="../TTY/index.html#type-t"><code>Luv.TTY.t</code></a></li></ul></header><dl><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type</span> <span>'kind t</span></code><code> = <span><span>[ <span>`Stream of <span class="type-var">'kind</span></span> ]</span> <a href="../Handle/index.html#type-t">Handle.t</a></span></code></dt><dd><p>Binds <a href="http://docs.libuv.org/en/v1.x/stream.html#c.uv_stream_t"><code>uv_stream_t</code></a>.</p></dd></dl><dl><dt class="spec value" id="val-shutdown"><a href="#val-shutdown" class="anchor"></a><code><span class="keyword">val</span> shutdown : <span><span class="type-var">_</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span>(<span><span>(unit, <a href="../Error/index.html#type-t">Error.t</a>)</span> Result.result</span> <span>&#45;&gt;</span> unit)</span> <span>&#45;&gt;</span> unit</code></dt><dd><p>Shuts down the write side of the stream.</p><p>Binds <a href="http://docs.libuv.org/en/v1.x/stream.html#c.uv_shutdown"><code>uv_shutdown</code></a>. See <a href="http://man7.org/linux/man-pages/man3/shutdown.3p.html"><code>shutdown(3p)</code></a>.</p></dd></dl><dl><dt class="spec value" id="val-listen"><a href="#val-listen" class="anchor"></a><code><span class="keyword">val</span> listen : <span>?&#8288;backlog:int</span> <span>&#45;&gt;</span> <span><span class="type-var">_</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span>(<span><span>(unit, <a href="../Error/index.html#type-t">Error.t</a>)</span> Result.result</span> <span>&#45;&gt;</span> unit)</span> <span>&#45;&gt;</span> unit</code></dt><dd><p>Starts listening for incoming connections.</p><p>Binds <a href="http://docs.libuv.org/en/v1.x/stream.html#c.uv_listen"><code>uv_listen</code></a>. See <a href="http://man7.org/linux/man-pages/man3/listen.3p.html"><code>listen(3p)</code></a>.</p><p>The default value of <code>?backlog</code> is <code>SOMAXCONN</code>.</p></dd></dl><dl><dt class="spec value" id="val-accept"><a href="#val-accept" class="anchor"></a><code><span class="keyword">val</span> accept : <span>server:<span><span class="type-var">'kind</span> <a href="index.html#type-t">t</a></span></span> <span>&#45;&gt;</span> <span>client:<span><span class="type-var">'kind</span> <a href="index.html#type-t">t</a></span></span> <span>&#45;&gt;</span> <span><span>(unit, <a href="../Error/index.html#type-t">Error.t</a>)</span> Result.result</span></code></dt><dd><p>Accepts an incoming connection.</p><p>Binds <a href="http://docs.libuv.org/en/v1.x/stream.html#c.uv_accept"><code>uv_accept</code></a>. See <a href="http://man7.org/linux/man-pages/man3/accept.3p.html"><code>accept(3p)</code></a>.</p><p><code>~client</code> should be a freshly-initialized stream of the same kind as <code>~server</code>. In other words, if <code>~server</code> is a <a href="../TCP/index.html#type-t"><code>Luv.TCP.t</code></a>, <code>~client</code> should also be a <a href="../TCP/index.html#type-t"><code>Luv.TCP.t</code></a>, and should have been obtained from <a href="../TCP/index.html#val-init"><code>Luv.TCP.init</code></a>.</p></dd></dl><dl><dt class="spec value" id="val-read_start"><a href="#val-read_start" class="anchor"></a><code><span class="keyword">val</span> read_start : <span>?&#8288;allocate:<span>(int <span>&#45;&gt;</span> <a href="../Buffer/index.html#type-t">Buffer.t</a>)</span></span> <span>&#45;&gt;</span> <span><span class="type-var">_</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span>(<span><span>(<a href="../Buffer/index.html#type-t">Buffer.t</a>, <a href="../Error/index.html#type-t">Error.t</a>)</span> Result.result</span> <span>&#45;&gt;</span> unit)</span> <span>&#45;&gt;</span> unit</code></dt><dd><p>Calls its callback whenever data is available on the stream.</p><p>Binds <a href="http://docs.libuv.org/en/v1.x/stream.html#c.uv_read_start"><code>uv_read_start</code></a>. See <a href="http://man7.org/linux/man-pages/man3/read.3p.html"><code>read(3p)</code></a>.</p><p>The amount of data read is equal to the length of the buffer passed to the callback.</p><p><code>?allocate</code> is called immediately before each call to the main callback with <code>Ok buffer'</code>, to create <code>buffer</code>, into which the data will be read. <code>buffer'</code> is, in general, a <a href="../Buffer/index.html#val-sub"><span>view</span></a> into <code>buffer</code>. The default <code>?allocate</code> allocates a fresh buffer every time it is called. One particular use of <code>?allocate</code> is to always read data into the same pre-existing buffer. The <code>int</code> argument passed to <code>?allocate</code> is a suggested size. It is acceptable to return a buffer of a smaller size. To read into an existing buffer, but not at its beginning, use <a href="../Buffer/index.html#val-sub"><code>Luv.Buffer.sub</code></a> to create a view into the buffer.</p><p>The end of the stream (typically, when the remote peer closes or shuts down the connection) is indicated by <code>Error `EOF</code> being passed to the callback. Note that this behavior is different from <a href="../File/index.html#val-read"><code>Luv.File.read</code></a>.</p><p>Zero-length reads are possible, and do not indicate the end of stream. Instead, they usually indicate <code>EAGAIN</code> inside libuv; libuv still calls the callback in order to give the C user a chance to deallocate the data buffer. This is not usually an issue in OCaml, so a wrapper of this function can usually simply ignore zero-length reads. It is then also safe to convert <code>Error `EOF</code> to zero-length reads in a higher-level API, for consistency with reading files, and in accordance with OS API convention.</p><p>To read only once, call <a href="index.html#val-read_stop"><code>Luv.Stream.read_stop</code></a> immediately, in the main callback. Otherwise, the main callback will be called repeatedly.</p></dd></dl><dl><dt class="spec value" id="val-read_stop"><a href="#val-read_stop" class="anchor"></a><code><span class="keyword">val</span> read_stop : <span><span class="type-var">_</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span>(unit, <a href="../Error/index.html#type-t">Error.t</a>)</span> Result.result</span></code></dt><dd><p>Stops reading.</p><p>Binds <a href="http://docs.libuv.org/en/v1.x/stream.html#c.uv_read_stop"><code>uv_read_stop</code></a>.</p></dd></dl><dl><dt class="spec value" id="val-write"><a href="#val-write" class="anchor"></a><code><span class="keyword">val</span> write : <span><span class="type-var">_</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><a href="../Buffer/index.html#type-t">Buffer.t</a> list</span> <span>&#45;&gt;</span> <span>(<span><span>(unit, <a href="../Error/index.html#type-t">Error.t</a>)</span> Result.result</span> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> unit)</span> <span>&#45;&gt;</span> unit</code></dt><dd><p>Writes the given buffer to the stream.</p><p>Binds <a href="http://docs.libuv.org/en/v1.x/stream.html#c.uv_write"><code>uv_write</code></a>. See <a href="http://man7.org/linux/man-pages/man3/writev.3p.html"><code>writev(3p)</code></a>.</p><p>To write only part of a buffer, use <a href="../Buffer/index.html#val-sub"><code>Luv.Buffer.sub</code></a> to create a view into the buffer, and pass the view to this function <a href="index.html#val-write"><code>Luv.Stream.write</code></a>.</p><p>The second argument passed to the callback is the number of bytes written. libuv has an internal queue of writes, in part to implement retry. This means that writes can be partial at the libuv (and Luv) API level, so it is possible to receive both an <code>Error</code> result, and for some data to have been successfully written.</p></dd></dl><dl><dt class="spec value" id="val-write2"><a href="#val-write2" class="anchor"></a><code><span class="keyword">val</span> write2 : <span><span>[&lt; `Pipe ]</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><a href="../Buffer/index.html#type-t">Buffer.t</a> list</span> <span>&#45;&gt;</span> <span>send_handle:<span><span>[&lt; `TCP <span>| `Pipe</span> ]</span> <a href="index.html#type-t">t</a></span></span> <span>&#45;&gt;</span> <span>(<span><span>(unit, <a href="../Error/index.html#type-t">Error.t</a>)</span> Result.result</span> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> unit)</span> <span>&#45;&gt;</span> unit</code></dt><dd><p>Like <a href="index.html#val-write"><code>Luv.Stream.write</code></a>, but allows sending a TCP socket or pipe over the stream (<code>~send_handle</code>). The stream must be a pipe.</p><p>Binds <a href="http://docs.libuv.org/en/v1.x/stream.html#c.uv_write2"><code>uv_write2</code></a>.</p><p>See <a href="../Pipe/index.html#val-receive_handle"><code>Luv.Pipe.receive_handle</code></a>.</p></dd></dl><dl><dt class="spec value" id="val-try_write"><a href="#val-try_write" class="anchor"></a><code><span class="keyword">val</span> try_write : <span><span class="type-var">_</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><a href="../Buffer/index.html#type-t">Buffer.t</a> list</span> <span>&#45;&gt;</span> <span><span>(int, <a href="../Error/index.html#type-t">Error.t</a>)</span> Result.result</span></code></dt><dd><p>Like <a href="index.html#val-write"><code>Luv.Stream.write</code></a>, but only attempts to perform the write operation immediately.</p><p>Binds <a href="http://docs.libuv.org/en/v1.x/stream.html#c.uv_try_write"><code>uv_try_write</code></a>.</p></dd></dl><dl><dt class="spec value" id="val-is_readable"><a href="#val-is_readable" class="anchor"></a><code><span class="keyword">val</span> is_readable : <span><span class="type-var">_</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> bool</code></dt><dd><p>Indicates whether the given stream is readable (has data).</p><p>Binds <a href="http://docs.libuv.org/en/v1.x/stream.html#c.uv_is_readable"><code>uv_is_readable</code></a>.</p></dd></dl><dl><dt class="spec value" id="val-is_writable"><a href="#val-is_writable" class="anchor"></a><code><span class="keyword">val</span> is_writable : <span><span class="type-var">_</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> bool</code></dt><dd><p>Indicates whether the given stream is writable (has space in buffers).</p><p>Binds <a href="http://docs.libuv.org/en/v1.x/stream.html#c.uv_is_writable"><code>uv_is_writable</code></a>.</p></dd></dl><dl><dt class="spec value" id="val-set_blocking"><a href="#val-set_blocking" class="anchor"></a><code><span class="keyword">val</span> set_blocking : <span><span class="type-var">_</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> bool <span>&#45;&gt;</span> <span><span>(unit, <a href="../Error/index.html#type-t">Error.t</a>)</span> Result.result</span></code></dt><dd><p>Sets the blocking mode of a stream.</p><p>Binds <a href="http://docs.libuv.org/en/v1.x/stream.html#c.uv_stream_set_blocking"><code>uv_stream_set_blocking</code></a>.</p></dd></dl></div></body></html>